(()=>{"use strict";class e{constructor(e,t=null,r=null){this.data=e,this.left=t,this.right=r}}class t{constructor(e){this.root=this.buildTree(e)}sortArray(e){return[...new Set(e)].sort(((e,t)=>e-t))}buildTree(t){let r=this.sortArray(t);if(0===r.length)return null;const l=parseInt(r.length/2),s=new e(r[l]);return s.left=this.buildTree(r.slice(0,l)),s.right=this.buildTree(r.slice(l+1)),s}insert(t,r=this.root){return null===r?new e(t):(r.data<t?r.right=this.insert(t,r.right):r.left=this.insert(t,r.left),r)}min(e){for(;null!==e.left;)e=e.left;return e.data}delete(e=this.root,t){if(null===e)return e;if(t<e.data)e.left=this.delete(e.left,t);else if(t>e.data)e.right=this.delete(e.right,t);else{if(!e.left&&!e.right)return null;if(!e.left)return e.right;if(!e.right)return e.left;e.data=this.min(e.right),e.right=this.delete(e.right,e.data)}return e}find(e=this.root,t){return e.data===t?e:t<e.data?this.find(e.left,t):t>e.data?this.find(e.right,t):e}levelOrderIterate(e=this.root,t){if(!e)return;let r=[e],l=[];for(;r.length>0;){const e=r.shift();t?t(e):l.push(e.data),e.left&&r.push(e.left),e.right&&r.push(e.right)}return console.log(l),l}levelOrderRecursive(e=this.root,t,r=[e],l=[]){if(!e||0===r.length)return l;const s=r.shift();return t?t(s):l.push(s.data),s.left&&r.push(s.left),s.right&&r.push(s.right),this.levelOrderRecursive(e,t,r,l)}inOrder(e=this.root,t,r=[]){return null===e||(this.inOrder(e.left,t,r),t?t(e):r.push(e.data),this.inOrder(e.right,t,r)),r}preOrder(e=this.root,t,r=[]){return null===e||(t?t(e):r.push(e.data),this.preOrder(e.left,t,r),this.preOrder(e.right,t,r)),r}postOrder(e=this.root,t,r=[]){return null===e||(this.postOrder(e.left,t,r),this.postOrder(e.right,t,r),t?t(e):r.push(e.data)),r}depth(e=this.root){if(null===e)return 0;const t=this.depth(e.left),r=this.depth(e.right);return Math.max(t,r)+1}isBalanced(e=this.root){if(null===e)return!0;const t=this.depth(e.left),r=this.depth(e.right);return Math.abs(t-r)<=1&&this.isBalanced(e.left)&&this.isBalanced(e.right)}rebalance(e=this.root){this.root=this.buildTree(this.inOrder(e))}}const r=(e,t="",l=!0)=>{null!==e&&(null!==e.right&&r(e.right,`${t}${l?"│   ":"    "}`,!1),console.log(`${t}${l?"└── ":"┌── "}${e.data}`),null!==e.left&&r(e.left,`${t}${l?"    ":"│   "}`,!0))};!function(){const e=function(e){const t=[];for(let e=0;e<10;e++)t.push(Math.floor(100*Math.random()));return t}(),l=new t(e);console.log("Here's your Tree!"),r(l.root),console.log("Is the tree Balanced?",l.isBalanced()),console.log("Level Order:",l.levelOrderRecursive()),console.log("Pre Order:",l.preOrder()),console.log("Post Order:",l.postOrder()),console.log("In Order:",l.inOrder()),l.insert(120),l.insert(130),l.insert(140),console.log("Adding 120, 130 & 140 to your tree! You're welcome!"),console.log("Is the tree unbalanced?",!l.isBalanced()),console.log("Rebalancing Tree..."),l.rebalance(),r(l.root),console.log("Is the tree balanced after rebalance?",l.isBalanced()),console.log("Level Order (after rebalance):",l.levelOrderIterate()),console.log("Pre Order (after rebalance):",l.preOrder()),console.log("Post Order (after rebalance):",l.postOrder()),console.log("In Order (after rebalance):",l.inOrder())}()})();