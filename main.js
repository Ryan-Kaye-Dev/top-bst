(()=>{"use strict";class t{constructor(t,e=null,r=null){this.data=t,this.left=e,this.right=r}}class e{constructor(t){this.root=this.buildTree(t)}sortArray(t){return[...new Set(t)].sort(((t,e)=>t-e))}buildTree(e){let r=this.sortArray(e);if(0===r.length)return null;const i=parseInt(r.length/2),l=new t(r[i]);return l.left=this.buildTree(r.slice(0,i)),l.right=this.buildTree(r.slice(i+1)),l}insert(e,r=this.root){return null===r?new t(e):(r.data<e?r.right=this.insert(e,r.right):r.left=this.insert(e,r.left),r)}min(t){for(;null!==t.left;)t=t.left;return t.data}delete(t=this.root,e){if(null===t)return t;if(e<t.data)t.left=this.delete(t.left,e);else if(e>t.data)t.right=this.delete(t.right,e);else{if(!t.left&&!t.right)return null;if(!t.left)return t.right;if(!t.right)return t.left;t.data=this.min(t.right),t.right=this.delete(t.right,t.data)}return t}find(t=this.root,e){return t.data===e?t:e<t.data?this.find(t.left,e):e>t.data?this.find(t.right,e):t}levelOrderIterate(t=this.root,e){if(!t)return;let r=[t],i=[];for(;r.length>0;){const t=r.shift();e?e(t):i.push(t.data),t.left&&r.push(t.left),t.right&&r.push(t.right)}return console.log(i),i}levelOrderRecursive(t=this.root,e,r=[t],i=[]){if(!t||0===r.length)return i;const l=r.shift();return e?e(l):i.push(l.data),l.left&&r.push(l.left),l.right&&r.push(l.right),this.levelOrderRecursive(t,e,r,i)}inOrder(t=this.root,e,r=[]){return null===t||(this.inOrder(t.left,e,r),e?e(t):r.push(t.data),this.inOrder(t.right,e,r)),r}preOrder(t=this.root,e,r=[]){return null===t||(e?e(t):r.push(t.data),this.preOrder(t.left,e,r),this.preOrder(t.right,e,r)),r}postOrder(t=this.root,e,r=[]){return null===t||(this.postOrder(t.left,e,r),this.postOrder(t.right,e,r),e?e(t):r.push(t.data)),r}depth(t=this.root){if(null===t)return 0;const e=this.depth(t.left),r=this.depth(t.right);return Math.max(e,r)+1}isBalanced(t=this.root){if(null===t)return!0;const e=this.depth(t.left),r=this.depth(t.right);return Math.abs(e-r)<=1&&this.isBalanced(t.left)&&this.isBalanced(t.right)}rebalance(t=this.root){this.root=this.buildTree(this.inOrder(t))}}const r=(t,e="",i=!0)=>{null!==t&&(null!==t.right&&r(t.right,`${e}${i?"│   ":"    "}`,!1),console.log(`${e}${i?"└── ":"┌── "}${t.data}`),null!==t.left&&r(t.left,`${e}${i?"    ":"│   "}`,!0))};function i(t){const e=document.createElement("p");e.textContent=t,document.getElementById("console-output").appendChild(e)}console.log=function(t){i(t)},function(){const t=function(t){const e=[];for(let t=0;t<10;t++)e.push(Math.floor(100*Math.random()));return e}(),l=new e(t);i("Here's your Tree!"),r(l.root),i("Is the tree Balanced?",l.isBalanced()),i("Level Order:",l.levelOrderRecursive()),i("Pre Order:",l.preOrder()),i("Post Order:",l.postOrder()),i("In Order:",l.inOrder()),l.insert(120),l.insert(130),l.insert(140),i("Adding 120, 130 & 140 to your tree! You're welcome!"),i("Is the tree unbalanced?",l.isBalanced()),i("Rebalancing Tree..."),l.rebalance(),r(l.root),i("Is the tree balanced after rebalance?",l.isBalanced()),i("Level Order (after rebalance):",l.levelOrderIterate()),i("Pre Order (after rebalance):",l.preOrder()),i("Post Order (after rebalance):",l.postOrder()),i("In Order (after rebalance):",l.inOrder())}()})();